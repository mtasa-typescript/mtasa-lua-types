// Autogenerated file.
// DO NOT EDIT. ANY CHANGES WILL BE OVERWRITTEN

import {
    ProgressBar,
    Gui,
    EngineTXD,
    EngineDFF,
    EngineCOL,
    EngineIFP,
    PrimitiveType,
    DxTexture,
    ObjectGroup,
    Browser,
    Light,
    Effect,
    Searchlight,
    Weapon,
    GuiBrowser,
    GuiMemo,
    GuiElement,
    GuiEdit,
    GuiScrollBar,
    GuiWindow,
    Projectile,
    Material,
    Svg,
    SvgCallback,
    Userdata,
    TextItem,
    Pickup,
    Request,
    Player,
    Blip,
    ColShape,
    Element,
    Ped,
    Resource,
    Team,
    Vehicle,
    XmlNode,
    File,
    Marker,
    MTASAObject,
    RadarArea,
    Water,
    Timer,
    HandleFunction,
    TimerCallbackFunction,
    FetchRemoteCallback,
    GenericEventHandler,
    CommandHandler,
    BindKeyCallback,
    BindKeyCallbackVarArgs,
    ControlName,
    KeyName,
    KeyState,
    Vector2,
    Vector3,
    Vector4,
    Matrix,
} from '../structure';

/**
 * This function converts Texture_pixels|pixels from one format to another.
 * @see https://wiki.multitheftauto.com/wiki/DxConvertPixels
 * @param pixels The pixels to convert the format of
 * @param newFormat The new format required (plain or png or jpeg)
 * @param quality The quality of the returned pixels if the new format is jpeg
 * @return returns a copy of the pixels in the new format, or false if invalid arguments were passed
 * to the function.
 * @noSelf
 */
export declare function dxConvertPixels(
    pixels: string,
    newFormat: string,
    quality?: number,
): string;

/**
 * <br/>
 * This function creates a DX font element that can be used in dxDrawText. Successful font
 * creation is not guaranteed, and may fail due to hardware or memory limitations.
 * To see if creation is likely to fail, use dxGetStatus. (When VideoMemoryFreeForMTA is
 * zero, failure is guaranteed.)
 * @see https://wiki.multitheftauto.com/wiki/DxCreateFont
 * @param filepath the name of the file containing the font
 * @param size size of the font
 * @param bold flag to indicate if the font should be bold
 * @param quality the font quality
 * ** "default": not the actual default
 * ** "draft"
 * ** "proof": the default
 * ** "nonantialiased"
 * ** "antialiased"
 * ** "cleartype"
 * ** "cleartype_natural"
 * @return returns a dx font element if successful, false if invalid arguments were passed to the
 * function, or there is insufficient resources available.
 * you should always check to see if this function has returned false.
 * @noSelf
 */
export declare function dxCreateFont(
    filepath: string,
    size?: number,
    bold?: boolean,
    quality?: string,
): Element;

/**
 * This function creates a render target element, which is a special type of texture that
 * can be drawn on with the dx functions. Successful render target creation is not
 * guaranteed, and may fail due to hardware or memory limitations.
 * To see if creation is likely to fail, use dxGetStatus. (When VideoMemoryFreeForMTA is
 * zero, failure is guaranteed.)
 * @see https://wiki.multitheftauto.com/wiki/DxCreateRenderTarget
 * @param width The width of the texture in pixels.
 * @param height The height of the texture in pixels.
 * @param withAlpha The render target will be created with an alpha channel. false will turn images alpha
 * channels to black color
 * @return returns a texture element if successful, false if the system is unable to create a render
 * target.
 * you should always check to see if this function has returned false.
 * @noSelf
 */
export declare function dxCreateRenderTarget(
    width: number,
    height: number,
    withAlpha?: boolean,
): Element;

/**
 * This function creates a screen source, which is a special type of texture that contains
 * the screen as rendered by GTA
 * Note that successful screen source creation is not guaranteed, and may fail due to
 * hardware or memory limitations. You should always check to see if this function has
 * returned false.
 * @see https://wiki.multitheftauto.com/wiki/DxCreateScreenSource
 * @param width The width of the texture in pixels.
 * @param height The height of the texture  in pixels.
 * @return returns a texture element if successful, false if invalid arguments were passed to the
 * function.
 * @noSelf
 */
export declare function dxCreateScreenSource(
    width: number,
    height: number,
): Element;

/**
 * This function creates a shader element that can be used in the dxDraw functions.
 * Successful shader creation is not guaranteed unless the shader|Effect File contains a
 * fallback technique which will work on every existing PC.
 * <syntaxhighlight lang=lua>
 * element, string dxCreateShader ( string filepath / string raw_data , float priority = 0,
 * float maxDistance = 0, bool layered = false, string elementTypes =
 * world,vehicle,object,other  )
 * </syntaxhighlight>
 * *filepath / raw_data: The filepath of the shader|shader  Effect File (.fx) file or whole
 * data buffer of the shader file
 * All the following optional arguments are only relevant when the shader is used with
 * engineApplyShaderToWorldTexture
 * *priority: If more than one shader is matched to a world texture, the shader with the
 * highest priority will be used. If there is more than one shader with the same highest
 * priority, the most recently created shader is used.
 * *maxDistance: If non-zero, the shader will be applied to textures nearer than maxDistance
 * only. This can speed up rendering, but (to look good) may require the shader to fade out
 * its own effect as the texture reaches maxDistance.
 * *layered: When set to true, the shader will be drawn in a separate render pass. Several
 * layered shaders can be drawn on the same world texture. (To avoid
 * http://en.wikipedia.org/wiki/Z-fighting Z fighting artifacts, you may have to add
 * DepthBias<nowiki>=</nowiki>-0.0002; to the technique pass, but this might cause visual
 * artifacts when applied on vehicles)
 * *elementTypes: A comma seperated list of element types to restrict this shader to. Valid
 * element types are:
 * ** world - Textures in the GTA world
 * ** ped - Player and ped textures
 * ** vehicle - Vehicles textures
 * ** object - Objects textures
 * ** other - Element textures which are not peds, vehicles or objects
 * ** all - Everything
 * *element: A shader element if successful, false if invalid arguments were passed to the
 * function. You should always check to see if this function has returned false.
 * *string: The name of the technique that will be used.
 * |20688}}
 * <syntaxhighlight lang=lua>
 * element, string dxCreateShader ( string filepath / string raw_data  , table macros = {} ,
 * float priority = 0, float maxDistance = 0, bool layered = false, string elementTypes =
 * world,vehicle,object,other  )
 * </syntaxhighlight>
 * *filepath / raw_data: The filepath of the shader|shader  Effect File (.fx) file or whole
 * data buffer of the shader file
 * All the following optional arguments are only relevant when the shader is used with
 * engineApplyShaderToWorldTexture
 * *macros: A table contains macros in an ordered and/or unordered way. See example below.
 * *priority: If more than one shader is matched to a world texture, the shader with the
 * highest priority will be used. If there is more than one shader with the same highest
 * priority, the most recently created shader is used.
 * *maxDistance: If non-zero, the shader will be applied to textures nearer than maxDistance
 * only. This can speed up rendering, but (to look good) may require the shader to fade out
 * its own effect as the texture reaches maxDistance.
 * *layered: When set to true, the shader will be drawn in a separate render pass. Several
 * layered shaders can be drawn on the same world texture. (To avoid
 * http://en.wikipedia.org/wiki/Z-fighting Z fighting artifacts, you may have to add
 * DepthBias<nowiki>=</nowiki>-0.0002; to the technique pass, but this might cause visual
 * artifacts when applied on vehicles)
 * *elementTypes: A comma seperated list of element types to restrict this shader to. Valid
 * element types are:
 * ** world - Textures in the GTA world
 * ** ped - Player and ped textures
 * ** vehicle - Vehicles textures
 * ** object - Objects textures
 * ** other - Element textures which are not peds, vehicles or objects
 * ** all - Everything
 * *element: A shader element if successful, false if invalid arguments were passed to the
 * function. You should always check to see if this function has returned false.
 * *string: The name of the technique that will be used.
 * @see https://wiki.multitheftauto.com/wiki/DxCreateShader
 * @noSelf
 */
export declare function dxCreateShader(
    filepath: string | string,
    priority?: number,
    maxDistance?: number,
    layered?: boolean,
    elementTypes?: string,
): LuaMultiReturn<[Element, string]>;

/**
 * This function creates a texture element that can be used in the dxDraw functions.
 * It is possible to use dxCreateTexture to load cubemaps and volume textures, but these
 * will only be useable as inputs for a shader. The Microsoft utility
 * http://nightly.mtasa.com/files/shaders/DxTex.zip DxTex can view and change cubemaps and
 * volume textures. DxTex can also convert standard textures into DXT1/3/5 compressed .dds
 * which should reduce file sizes.
 * @see https://wiki.multitheftauto.com/wiki/DxCreateTexture
 * @param filepath The filepath of the image. (.bmp, .dds, .jpg, .png, and .tga images are supported). Image
 * files should ideally have dimensions that are a power of two, to prevent possible
 * blurring.
 * or
 * @param pixels Texture_pixels|Pixels containing image data. (plain, jpeg or png pixels can be used here)
 * or
 * @param width Desired width, preferably power of two (16, 32, 64 etc.), maximum is 16384
 * @param height Desired height, preferably power of two (16, 32, 64 etc.), maximum is 16384
 * @param textureFormat A string representing the desired texture format, which can be one of:
 * @param argb : ARGB uncompressed 32 bit color (default).
 * @param dxt1 : DXT1 compressed - Can take a fraction of a second longer to load (unless the file is
 * already a DXT1 .dds). Uses 8 times less video memory than ARGB and can speed up drawing.
 * Quality not as good as ARGB. It supports alpha blending, but it can only be on or off,
 * that is: either 0 or 255.
 * @param dxt3 : DXT3 compressed - Can take a fraction of a second longer to load (unless the file is
 * already a DXT3 .dds). Uses 4 times less video memory than ARGB and can speed up drawing.
 * Quality slightly better than DXT1 and supports crisp alpha blending.
 * @param dxt5 : DXT5 compressed - Can take a fraction of a second longer to load (unless the file is
 * already a DXT5 .dds). Uses 4 times less video memory than ARGB and can speed up drawing.
 * Quality slightly better than DXT1 and supports smooth alpha blending.
 * @param mipmaps True to create a mip-map chain so the texture looks good when drawn at various sizes.
 * @param textureEdge A string representing the desired texture edge handling, which can be one of:
 * @param wrap : Wrap the texture at the edges (default)
 * @param clamp : Clamp the texture at the edges. This may help avoid edge artifacts.
 * @param mirror : Mirror the texture at the edges.
 * @param textureType A string representing the desired texture type, which can be one of:
 * @param 2d : Standard texture (default)
 * @param 3d : Volume texture
 * @param cube : Cube map
 * @param depth Desired number of slices when creating a volume texture
 * @return returns a texture if successful, false if invalid arguments were passed to the function.
 * @noSelf
 */
export declare function dxCreateTexture(
    pixels: string | string,
    textureFormat?: string,
    mipmaps?: boolean,
    textureEdge?: string,
): DxTexture;

/**
 * This function creates a texture element that can be used in the dxDraw functions
 * @see https://wiki.multitheftauto.com/wiki/DxCreateTexture
 * @return Returns a texture if successful, false if invalid arguments were passed to the function.
 * @noSelf
 */
export declare function dxCreateTexture(
    width: number,
    height: number,
    textureFormat?: string,
    textureEdge?: string,
    textureType?: string,
    depth?: number,
): DxTexture;

/**
 * <lowercasetitle/>
 * @see https://wiki.multitheftauto.com/wiki/DxDrawCircle
 * @param posX : An integer representing the absolute X position of the circle center, represented by
 * pixels on the screen.
 * @param posY : An integer representing the absolute Y position of the circle center, represented by
 * pixels on the screen.
 * @param radius : An integer representing the radius scale of the circle that is being drawn.
 * @param startAngle : An integer representing the angle of the first point of the circle.
 * @param stopAngle : An integer representing the angle of the last point of the circle.
 * @param theColor : An integer of the hex color, produced using tocolor or 0xAARRGGBB (AA = alpha, RR =
 * red, GG = green, BB = blue).
 * @param theCenterColor : An integer of the hex color, produced using tocolor or 0xAARRGGBB (AA = alpha, RR =
 * red, GG = green, BB = blue).
 * @param segments : An integer ranging from 3-1024 representing how many triangles are used to form the
 * circle, more segments = smoother circle. Note: using lots of segments may cause lag.
 * @param ratio : Ratio between width and height, e.g: 2 would mean that the width of the circle is 2
 * times the height.
 * @param postGUI : A bool representing whether the circle should be drawn on top of or behind any ingame
 * GUI (rendered by CEGUI).
 * @return returns true if the creation of the 2d circle was successful, false otherwise.
 * @noSelf
 */
export declare function dxDrawCircle(
    posX: number,
    posY: number,
    radius: number,
    startAngle?: number,
    stopAngle?: number,
    theColor?: number,
    theCenterColor?: number,
    segments?: number,
    ratio?: number,
    postGUI?: boolean,
): boolean;

/**
 * Draws an image on the screen for a single frame. In order for the image to stay visible
 * continuously, you need to call this function with the same parameters on each frame
 * update (see onClientRender).<br/>
 * Image files should ideally have dimensions that are a power of two, to prevent possible
 * blurring.<br/>
 * <b>Power of two: 2px, 4px, 8px, 16px, 32px, 64px, 128px, 256px, 512px, 1024px...</b>
 * @see https://wiki.multitheftauto.com/wiki/DxDrawImage
 * @param posX the absolute X coordinate of the top left corner of the image
 * @param posY the absolute Y coordinate of the top left corner of the image
 * @param width the absolute width of the image
 * @param height the absolute height of the image
 * @param image Either a material element or a filepath of the image which is going to be drawn. (.dds
 * images are also supported). Image files should ideally have dimensions that are a power
 * of two, to prevent possible blurring. Use a texture created with dxCreateTexture to speed
 * up drawing.
 * @param rotation the rotation, in degrees for the image.
 * @param rotationCenterOffsetX the absolute X offset from the image center for which to rotate the image from.
 * @param rotationCenterOffsetY the absolute Y offset from the image center for which to rotate the image from.
 * @param color Tints the image with a value produced by tocolor or hexadecimal number in format:
 * 0xAARRGGBB (RR = red, GG = green, BB = blue, AA = alpha).
 * @param postGUI A bool representing whether the image should be drawn on top of or behind any ingame GUI
 * (rendered by CEGUI).
 * @return returns true if successful, false otherwise.
 * @noSelf
 */
export declare function dxDrawImage(
    posX: number,
    posY: number,
    width: number,
    height: number,
    image: any,
    rotation?: number,
    rotationCenterOffsetX?: number,
    rotationCenterOffsetY?: number,
    color?: number,
    postGUI?: boolean,
): boolean;

/**
 * Differing from dxDrawImage, this function only draws a part of an image on the screen for
 * a single frame. In order for the image to stay visible continuously, you need to call
 * this function with the same parameters on each frame update (see onClientRender).
 * Image files should ideally have dimensions that are a power of two, to prevent possible
 * blurring.<br/>
 * <b>Power of two: 2px, 4px, 8px, 16px, 32px, 64px, 128px, 256px, 512px, 1024px...</b>
 * @see https://wiki.multitheftauto.com/wiki/DxDrawImageSection
 * @param posX the absolute X coordinate of the top left corner of the image
 * @param posY the absolute Y coordinate of the top left corner of the image
 * @param width the absolute width of the image
 * @param height the absolute height of the image
 * @param u the absolute X coordinate of the top left corner of the section which should be drawn
 * from image
 * @param v the absolute Y coordinate of the top left corner of the section which should be drawn
 * from image
 * @param usize the absolute width of the image section
 * @param vsize the absolute height of the image section
 * @param image Either a material element or a filepath of the image which is going to be drawn. (.dds
 * images are also supported). Image files should ideally have dimensions that are a power
 * of two, to prevent possible blurring. Use a texture created with dxCreateTexture to speed
 * up drawing.
 * @param rotation the rotation, in degrees for the image.
 * @param rotationCenterOffsetX the absolute X offset from the image center for which to rotate the image from.
 * @param rotationCenterOffsetY the absolute Y offset from the image center for which to rotate the image from.
 * @param color the color of the image, a value produced by tocolor or hexadecimal number in format:
 * 0xAARRGGBB (AA = alpha, RR = red, GG = green, BB = blue).
 * @param postgui A bool representing whether the image should be drawn on top of or behind any ingame GUI
 * (rendered by CEGUI).
 * @return returns true if successful, false otherwise.
 * @noSelf
 */
export declare function dxDrawImageSection(
    posX: number,
    posY: number,
    width: number,
    height: number,
    u: number,
    v: number,
    usize: number,
    vsize: number,
    image: any,
    rotation?: number,
    rotationCenterOffsetX?: number,
    rotationCenterOffsetY?: number,
    color?: number,
    postGUI?: boolean,
): boolean;

/**
 * This function draws a 2D line across the screen - rendered for one frame.  This should be
 * used in conjunction with onClientRender in order to display continuously.
 * @see https://wiki.multitheftauto.com/wiki/DxDrawLine
 * @param startX An integer representing the absolute start X position of the line, represented by pixels
 * on the screen.
 * @param startY An integer representing the absolute start Y position of the line, represented by pixels
 * on the screen.
 * @param endX An integer representing the absolute end X position of the line, represented by pixels on
 * the screen.
 * @param endY An integer representing the absolute end Y position of the line, represented by pixels on
 * the screen.
 * @param color An integer of the hex color, produced using tocolor or 0xAARRGGBB (AA = alpha, RR = red,
 * GG = green, BB = blue).
 * @param width The width/thickness of the line
 * @param postGUI A bool representing whether the line should be drawn on top of or behind any ingame GUI
 * (rendered by CEGUI).
 * Returns a true if the operation was successful, false otherwise.
 * @return returns a true if the operation was successful, false otherwise.
 * @noSelf
 */
export declare function dxDrawLine(
    startX: number,
    startY: number,
    endX: number,
    endY: number,
    color: number,
    width?: number,
    postGUI?: boolean,
): boolean;

/**
 * This function draws a 3D line between two points in the 3D world - rendered for one
 * frame.  This should be used in conjunction with onClientRender in order to display
 * continuously.
 * @see https://wiki.multitheftauto.com/wiki/DxDrawLine3D
 * @param startX The start X position of the 3D line, representing a coordinate in the GTA world.
 * @param startY The start Y position of the 3D line, representing a coordinate in the GTA world.
 * @param startZ The start Z position of the 3D line, representing a coordinate in the GTA world.
 * @param endX The end X position of the 3D line, representing a coordinate in the GTA world.
 * @param endY The end Y position of the 3D line, representing a coordinate in the GTA world.
 * @param endZ The end Z position of the 3D line, representing a coordinate in the GTA world.
 * @param color An integer of the hex color, produced using tocolor or 0xAARRGGBB (AA = alpha, RR = red,
 * GG = green, BB = blue).
 * @param width The width/thickness of the line
 * @param postGUI A bool representing whether the line should be drawn on top of or behind any ingame GUI
 * (rendered by CEGUI).
 * Returns a ''true'' if the operation was successful, ''false'' otherwise.
 * @return returns a true if the operation was successful, false otherwise.
 * @noSelf
 */
export declare function dxDrawLine3D(
    startX: number,
    startY: number,
    startZ: number,
    endX: number,
    endY: number,
    endZ: number,
    color?: number,
    width?: number,
    postGUI?: boolean,
): boolean;

/**
 * This function draws a textured 3D line between two points in the 3D world - rendered for
 * one frame.  This should be used in conjunction with onClientPreRender in order to display
 * continuously.
 * The 3D line with a large width value effectively becomes a rectangle, so it it possible
 * to construct basic shapes such as boxes with several large width lines and the
 * appropriate values for faceToward.
 * 3D lines are drawn at a particular place in the Game_Processing_Order|game processing
 * order, so use onClientPreRender for drawing if you are attaching them to world elements.
 * @see https://wiki.multitheftauto.com/wiki/DxDrawMaterialLine3D
 * @param startX/Y/Z The start position of the 3D line, representing a coordinate in the GTA world.
 * @param endX/Y/Z The end position of the 3D line, representing a coordinate in the GTA world.
 * @param material A material to draw the line with.
 * @param width The width/thickness of the line in GTA world units. (This is 1/75th of the width used in
 * dxDrawLine3D)
 * @param flipUV : A bool representing whether a UV orientation should be flipped.
 * @param color An int|integer of the hex color, produced using tocolor or 0xAARRGGBB (AA = alpha, RR =
 * red, GG = green, BB = blue).
 * @param postGUI : A bool representing whether the line should be drawn on top of or behind any ingame GUI.
 * @param faceTowardX/Y/Z The position the front of the line should face towards. If this is not set, the camera
 * position is used, so the front of the line faces toward the camera.
 * Returns a ''true'' if the operation was successful, ''false'' otherwise.
 * @return returns a true if the operation was successful, false otherwise.
 * @noSelf
 */
export declare function dxDrawMaterialLine3D(
    startX: number,
    startY: number,
    startZ: number,
    endX: number,
    endY: number,
    endZ: number,
    flipUV: boolean,
    material: Element,
    width: number,
    color?: number,
    postGUI?: boolean,
    faceTowardX?: number,
    faceTowardY?: number,
    faceTowardZ?: number,
): boolean;

/**
 * @see https://wiki.multitheftauto.com/wiki/DxDrawMaterialLine3D
 * @noSelf
 */
export declare function dxDrawMaterialLine3D(
    startX: number,
    startY: number,
    startZ: number,
    endX: number,
    endY: number,
    endZ: number,
    material: Element,
    width: number,
    color?: number,
    postGUI?: boolean,
    faceTowardX?: number,
    faceTowardY?: number,
    faceTowardZ?: number,
): boolean;

/**
 * If image file is used, it should ideally have dimensions that are a power of two, to
 * prevent possible blurring.
 * Power of two: 2px, 4px, 8px, 16px, 32px, 64px, 128px, 256px, 512px, 1024px...}}
 * @see https://wiki.multitheftauto.com/wiki/DxDrawMaterialPrimitive
 * @param pType Type of primitive to be drawn.
 * @param image Either a material element or a filepath of the image which is going to be drawn. (.dds
 * images are also supported). Image files should ideally have dimensions that are a power
 * of two, to prevent possible blurring. Use a texture created with dxCreateTexture to speed
 * up drawing.
 * @param postGUI A bool representing whether the line should be drawn on top of or behind any ingame GUI
 * (rendered by CEGUI).
 * @param vertices Tables representing each primitive vertice, required amount of them is determined by
 * primitive type.
 * @return returns a true if the operation was successful, false otherwise.
 * @noSelf
 */
export declare function dxDrawMaterialPrimitive(
    pType: PrimitiveType,
    material: any,
    postGUI: boolean,
    vertice1: LuaTable,
    vertice2?: LuaTable,
    ...varargs: any[]
): boolean;

/**
 * This function draws a 3D primitive shape with material applied to it in the 3D world -
 * rendered for one frame. This should be used in conjunction with onClientRender in order
 * to display continuously.
 * If image file is used, it should ideally have dimensions that are a power of two, to
 * prevent possible blurring.
 * Power of two: 2px, 4px, 8px, 16px, 32px, 64px, 128px, 256px, 512px, 1024px...
 * @see https://wiki.multitheftauto.com/wiki/DxDrawMaterialPrimitive3D
 * @param pType Type of primitive to be drawn.
 * @param image Either a material element or a filepath of the image which is going to be drawn. (.dds
 * images are also supported). Image files should ideally have dimensions that are a power
 * of two, to prevent possible blurring. Use a texture created with dxCreateTexture to speed
 * up drawing.
 * @param postGUI A bool representing whether the line should be drawn on top of or behind any ingame GUI
 * (rendered by CEGUI).
 * @param vertices Tables representing each primitive vertice, required amount of them is determined by
 * primitive type.
 * @return returns a true if the operation was successful, false otherwise.
 * @noSelf
 */
export declare function dxDrawMaterialPrimitive3D(
    pType: PrimitiveType,
    material: any,
    postGUI: boolean,
    vertice1: LuaTable,
    vertice2?: LuaTable,
    ...varargs: any[]
): boolean;

/**
 * This function draws a textured 3D line between two points in the 3D world - rendered for
 * one frame.  This should be used in conjunction with onClientPreRender in order to display
 * continuously.
 * The 3D line with a large width value effectively becomes a rectangle, so it it possible
 * to construct basic shapes such as boxes with several large width lines and the
 * appropriate values for faceToward.
 * @see https://wiki.multitheftauto.com/wiki/DxDrawMaterialSectionLine3D
 * @param startX/Y/Z The start position of the 3D line, representing a coordinate in the GTA world.
 * @param endX/Y/Z The end position of the 3D line, representing a coordinate in the GTA world.
 * @param u the absolute X coordinate of the top left corner of the section
 * @param v the absolute Y coordinate of the top left corner of the section
 * @param usize the absolute width of the section
 * @param vsize the absolute height of the section
 * @param material A material to draw the line with.
 * @param width The width/thickness of the line in GTA world units. (This is 1/75th of the width used in
 * dxDrawLine3D)
 * @param flipUV : A bool representing whether a UV orientation should be flipped.
 * @param color An integer of the hex color, produced using tocolor or 0xAARRGGBB (AA = alpha, RR = red,
 * GG = green, BB = blue).
 * @param postGUI : A bool representing whether the line should be drawn on top of or behind any ingame GUI.
 * @param faceTowardX/Y/Z The direction the front of the line should face towards. If this is not set, the front of
 * the line always faces toward the camera.
 * Returns a ''true'' if the operation was successful, ''false'' otherwise.
 * @return returns a true if the operation was successful, false otherwise.
 * @noSelf
 */
export declare function dxDrawMaterialSectionLine3D(
    startX: number,
    startY: number,
    startZ: number,
    endX: number,
    endY: number,
    endZ: number,
    u: number,
    v: number,
    usize: number,
    vsize: number,
    flipUV: boolean,
    material: Element,
    width: number,
    color?: number,
    postGUI?: boolean,
    faceTowardX?: number,
    faceTowardY?: number,
    faceTowardZ?: number,
): boolean;

/**
 * @see https://wiki.multitheftauto.com/wiki/DxDrawMaterialSectionLine3D
 * @noSelf
 */
export declare function dxDrawMaterialSectionLine3D(
    startX: number,
    startY: number,
    startZ: number,
    endX: number,
    endY: number,
    endZ: number,
    u: number,
    v: number,
    usize: number,
    vsize: number,
    material: Element,
    width: number,
    color?: number,
    postGUI?: boolean,
    faceTowardX?: number,
    faceTowardY?: number,
    faceTowardZ?: number,
): boolean;

/**
 * @see https://wiki.multitheftauto.com/wiki/DxDrawPrimitive
 * @param pType Type of primitive to be drawn.
 * @param postGUI A bool representing whether the line should be drawn on top of or behind any ingame GUI
 * (rendered by CEGUI).
 * @param vertices Tables representing each primitive vertice, required amount of them is determined by
 * primitive type.
 * @return returns a true if the operation was successful, false otherwise.
 * @noSelf
 */
export declare function dxDrawPrimitive(
    pType: string,
    postGUI: boolean,
    vertice1: LuaTable,
    vertice2?: LuaTable,
    ...varargs: any[]
): boolean;

/**
 * This function draws a 3D primitive in the 3D world - rendered for one frame.  This should
 * be used in conjunction with onClientRender in order to display continuously.
 * @see https://wiki.multitheftauto.com/wiki/DxDrawPrimitive3D
 * @param primitiveType The type of primitive to be drawn. This could be:
 * "pointlist"
 * "linelist"
 * "linestrip"
 * "trianglefan"
 * "trianglelist"
 * "trianglestrip"
 * @param postGUI A bool representing whether the line should be drawn on top of or behind any ingame GUI
 * (rendered by CEGUI).
 * @param vertex1 A table with the coordinates of the vertex plus its color.
 * @param vertex2 A table with the coordinates of the vertex plus its color.
 * @param vertex3 A table with the coordinates of the vertex plus its color.
 * The vertex should be passed like this:
 * <syntaxhighlight lang="lua">
 * {x, y, z, color}
 * </syntaxhighlight>
 * @param vertexN A table with the coordinates of the vertex plus its color. You can add as much as you
 * want.
 * Returns a ''true'' if the operation was successful, ''false'' otherwise.
 * @return returns a true if the operation was successful, false otherwise.
 * @noSelf
 */
export declare function dxDrawPrimitive3D(
    primitiveType: string,
    postGUI: boolean,
    vertex1: LuaTable,
    vertex2: LuaTable,
    vertex3: LuaTable,
    vertex4?: LuaTable,
    ...varargs: any[]
): boolean;

/**
 * This function draws a 2D rectangle across the screen - rendered for one frame. This
 * should be used in conjunction with onClientRender in order to display continuously.
 * @see https://wiki.multitheftauto.com/wiki/DxDrawRectangle
 * @param startX An float representing the absolute origin X position of the rectangle, represented by
 * pixels on the screen.
 * @param startY An float representing the absolute origin Y position of the rectangle, represented by
 * pixels on the screen.
 * @param width An float representing the width of the rectangle, drawn in a right direction from the
 * origin.
 * @param height An float representing the height of the rectangle, drawn in a downwards direction from
 * the origin.
 * @param color the hex color of the rectangle, produced using tocolor or 0xAARRGGBB (AA = alpha, RR =
 * red, GG = green, BB = blue).
 * @param postGUI A bool representing whether the line should be drawn on top of or behind any ingame GUI.
 * @param subPixelPositioning A bool representing whether the rectangle can be positioned sub-pixel-ly.
 * @return returns true if the operation was successful, false otherwise.
 * @noSelf
 */
export declare function dxDrawRectangle(
    startX: number,
    startY: number,
    width: number,
    height: number,
    color?: number,
    postGUI?: boolean,
    subPixelPositioning?: boolean,
): boolean;

/**
 * Draws a string of text on the screen for one frame. In order for the text to stay visible
 * continuously, you need to call this function with the same parameters on each frame
 * update (see onClientRender).
 * @see https://wiki.multitheftauto.com/wiki/DxDrawText
 * @param text the text to draw
 * @param leftX the absolute X coordinate of the top left corner of the text
 * @param topY the absolute Y coordinate of the top left corner of the text
 * @param rightX the absolute X coordinate of the right side of the text bounding box. Used for text
 * aligning, clipping and word breaking.
 * @param bottomY the absolute Y coordinate of the bottom side of the text bounding box. Used for text
 * aligning, clipping and word breaking.
 * @param color the color of the text, a value produced by tocolor or 0xAARRGGBB (AA = alpha, RR = red,
 * GG = green, BB = blue).
 * @param scale the size of the text.{{New feature|3.0110|1.1|scale: can (optionally) be specified as two
 * floats. i.e. scaleX, scaleY}}
 * @param font Either a custom DX font element or the name of a built-in DX font: Note: Some fonts are
 * incompatible with certain languages such as Arabic.
 * @param alignX horizontal alignment of the text within the bounding box. Can be left, center or right.
 * @param alignY vertical alignment of the text within the bounding box. Can be top, center or bottom.
 * @param clip if set to true, the parts of the text that dont fit within the bounding box will be cut
 * off.
 * @param wordBreak if set to true, the text will wrap to a new line whenever it reaches the right side of
 * the bounding box. If false, the text will always be completely on one line.
 * @param postGUI A bool representing whether the text should be drawn on top of or behind any ingame GUI
 * (rendered by CEGUI).
 * @param colorCoded Set to true to enable embedded #FFFFFF color codes. Note: clip and wordBreak are forced
 * false if this is set.
 * @param subPixelPositioning A bool representing whether the text can be positioned sub-pixel-ly. Looks nicer for
 * moving/scaling animations.
 * @param fRotation Rotation
 * @param fRotationCenterX Rotation Origin X
 * @param fRotationCenterY Rotation Origin Y
 * @param fLineSpacing Distance in pixels between the lines of text, this can be a negative number, works only
 * when colorCoded is set to true
 * @return returns true if successful, false otherwise.
 * @noSelf
 */
export declare function dxDrawText(
    text: string,
    leftX: number,
    topY: number,
    rightX?: number,
    bottomY?: number,
    color?: number,
    scaleXY?: number,
    scaleY?: number,
    font?: any,
    alignX?: string,
    alignY?: string,
    clip?: boolean,
    wordBreak?: boolean,
    postGUI?: boolean,
    colorCoded?: boolean,
    subPixelPositioning?: boolean,
    fRotation?: number,
    fRotationCenterX?: number,
    fRotationCenterY?: number,
    fLineSpacing?: number,
): boolean;

/**
 * This function drawn same sphere as /showcol. It provides 4 levels of iterations which
 * mean density of sphere. Adjust radius to iterations to get optimum density of mesh. About
 * 50 spheres with iterations = 4 can cause fps drop.
 * @see https://wiki.multitheftauto.com/wiki/DxDrawWiredSphere
 * @param x, y, z A position in world of sphere.
 * @param radius A radius of sphere.
 * @param theColor A color of sphere from tocolor function.
 * @param fLineWidth A width of line
 * @param iterations Number 1, 2, 3 or 4. 1 mean low density, 4 mean high.
 * @return returns a true if the operation was successful, false otherwise.
 * @noSelf
 */
export declare function dxDrawWiredSphere(
    x: number,
    y: number,
    z: number,
    radius: number,
    theColor: number,
    fLineWidth: number,
    iterations: number,
): boolean;

/**
 * This function returns the current blend mode for the dxDraw functions. The blend mode is
 * set using dxSetBlendMode
 * @see https://wiki.multitheftauto.com/wiki/DxGetBlendMode
 * @return returns the current blend mode, which can be one of:
 * *blend
 * *add
 * *modulate_add
 * *overwrite
 * @noSelf
 */
export declare function dxGetBlendMode(): string;

/**
 * This function retrieves the theoretical height of a certain piece of text, if it were to
 * be drawn using dxDrawText.
 * @see https://wiki.multitheftauto.com/wiki/DxGetFontHeight
 * @param scale The size of the text.
 * @param font Either a custom DX font element or the name of a built-in dx font:
 * @return returns an integer of the height of the text.
 * @noSelf
 */
export declare function dxGetFontHeight(scale?: number, font?: any): number;

/**
 * This gets the dimensions of the supplied material element.
 * @see https://wiki.multitheftauto.com/wiki/DxGetMaterialSize
 * @param material The material element whose size is to be gotten
 * @return returns two ints representing the width and height in pixels of the material, or false if
 * an invalid parameter was passed to the function.
 * if the material is a volume texture, this function will return three ints representing
 * the width, height and depth.
 * @noSelf
 */
export declare function dxGetMaterialSize(
    material: Element,
): LuaMultiReturn<[number, number, number | undefined]>;

/**
 * This function gets the color of a single pixel from Texture_pixels|pixels contained in a
 * string. It only works with plain format pixels.
 * @see https://wiki.multitheftauto.com/wiki/DxGetPixelColor
 * @param pixels The pixels to use
 * @param x The X coordinate for the pixel
 * @param y The Y coordinate for the pixel
 * @return returns 4 ints representing the rgba color value of the pixel if succesful, or false if
 * invalid arguments were passed to the function.
 * @noSelf
 */
export declare function dxGetPixelColor(
    pixels: string,
    x: number,
    y: number,
): LuaMultiReturn<[number, number, number, number]>;

/**
 * This function returns the format of Texture_pixels|pixels contained in a string.
 * @see https://wiki.multitheftauto.com/wiki/DxGetPixelsFormat
 * @param pixels The pixels to get the format of
 * @return returns the format of the pixels if successful (plain or png or jpeg), false if invalid
 * arguments were passed to the function.
 * @noSelf
 */
export declare function dxGetPixelsFormat(pixels: string): string;

/**
 * This function gets the dimensions of Texture_pixels|pixels contained in a string. It
 * works with all pixel formats.
 * @see https://wiki.multitheftauto.com/wiki/DxGetPixelsSize
 * @param pixels The pixels to get the dimensions of
 * @return returns width and height of the pixels if successful, false if invalid arguments were
 * passed to the function.
 * @noSelf
 */
export declare function dxGetPixelsSize(
    pixels: string,
): LuaMultiReturn<[number, number]>;

/**
 * This function gets information about various internal datum.
 * @see https://wiki.multitheftauto.com/wiki/DxGetStatus
 * @return returns a table with the following entries:
 * *testmode: the current dx test mode. see dxsettestmode.
 * *videocardname: the name of the graphics card.
 * *videocardram: the installed memory in mb of the graphics card.
 * *videocardpsversion: the maximum pixel shader version of the graphics card.
 * *videocardmaxanisotropy: the maximum anisotropic filtering available. (0-4 which
 * respectively mean: off, 2x, 4x, 8x, 16x)
 * *videocardnumrendertargets: the maximum number of simultaneous render targets a shader
 * can use.
 * *videomemoryfreeformta: the amount of memory in mb available for mta to use. when this
 * gets to zero, guicreatefont, dxcreatefont and dxcreaterendertarget will fail.
 * *videomemoryusedbyfonts: the amount of graphic memory in mb used by custom fonts.
 * *videomemoryusedbytextures: the amount of graphic memory in mb used by textures.
 * *videomemoryusedbyrendertargets: the amount of graphic memory in mb used by render
 * targets.
 * *settingwindowed: the windowed setting. (true/false)
 * *settingfullscreenstyle: display style when in full screen mode. (0-2 which respectively
 * mean: standard, borderless window, borderless keep res)
 * *settingfxquality: the fx quality. (0-3)
 * *settingdrawdistance: the draw distance setting. (0-100)
 * *settingvolumetricshadows: the volumetric shadows setting. (true/false)
 * *settingstreamingvideomemoryforgta: the usable graphics memory setting. (64-256)
 * *settinganisotropicfiltering: the anisotropic filtering setting. (0-4 which respectively
 * mean: off, 2x, 4x, 8x, 16x)
 * *settingantialiasing: the anti-aliasing setting. (0-3 which respectively mean: off, 1x,
 * 2x, 3x)
 * *settingheathaze: the heat haze setting. (true/false)
 * *settinggrasseffect: the grass effect setting. (true/false)
 * *setting32bitcolor: the color depth of the screen. (false is 16bit, true is 32bit)
 * *settinghudmatchaspectratio: the hud match aspect ratio setting. (true/false)
 * *settingaspectratio: the aspect ratio setting. (auto, 4:3, 16:10, 16:9)
 * *settingfov: the fov setting.
 * *settinghighdetailvehicles: high detail vehicles setting. (true/false)
 * *settinghighdetailpeds: high detail peds setting. (true/false)
 * *settingcoronareflections: corona rain reflections setting. (true/false)
 * *settingdynamicpedshadows: dynamic ped shadows setting. (true/false)
 * *allowscreenupload: the allows screen uploads setting. (true/false)
 * *depthbufferformat: the format of the shader readable depth buffer, or unknown if not
 * available.
 * *totalphysicalmemory: the amount of total physical memory in mb.
 * *usingdepthbuffer: true if the depth buffer is used, false otherwise.
 * @noSelf
 */
export declare function dxGetStatus(): LuaTable;

/**
 * NOTE: This function already takes the clients screen resolution into account.
 * @see https://wiki.multitheftauto.com/wiki/DxGetTextSize
 * @param text A string representing the text for which you wish to retrieve with width for.
 * @param width The width of the text. Use with wordBreak = true.
 * @param scaleX The scale of the text. Scale can also be inputted as a Vector2.
 * @param scaleY The scale of the text.
 * @param font Either a custom DX font element or the name of a built-in dx font:
 * @param wordBreak If set to true, the text will wrap to a new line whenever it reaches the right side of
 * the bounding box. If false, the text will always be completely on one line.
 * @param colorCoded Should we exclude color codes from the width? False will include the hex in the length.
 * Returns two floats representing the width and height of the text in pixels.
 * @return returns two floats representing the width and height of the text in pixels.
 * @noSelf
 */
export declare function dxGetTextSize(
    text: string,
    width?: number,
    scaleXY?: number,
    scaleY?: number,
    font?: any,
    wordBreak?: boolean,
    colorCoded?: boolean,
): LuaMultiReturn<[number, number]>;

/**
 * This function fetches the Texture_pixels|pixels from a texture element. It can be used
 * with a standard texture, render target or screen source.
 * *This function is slow and not something you want to be doing once a frame.
 * *It is slower when reading pixels from a render target or screen source.
 * *And is very slow indeed if the texture format is not  argb .
 * @see https://wiki.multitheftauto.com/wiki/DxGetTexturePixels
 * @param texture The texture element to get the pixels from
 * @param surfaceIndex Desired slice to get if the texture is a volume texture, or desired face to get if the
 * texture is a cube map. <nowiki>(Cube map faces: 0=+X 1=-X 2=+Y 3=-Y 4=+Z 5=-Z)</nowiki>
 * By default the pixels from the whole texture is returned. To get only a portion of the
 * texture, define a rectangular area using all four of these optional arguments:
 * @param x Rectangle left position
 * @param y Rectangle top position
 * @param width Rectangle width
 * @param height Rectangle height
 * @return returns a plain format pixels string if successful, false if invalid arguments were
 * passed to the function.
 * @noSelf
 */
export declare function dxGetTexturePixels(
    surfaceIndex: number,
    texture: Element,
    x?: number,
    y?: number,
    width?: number,
    height?: number,
): string;

/**
 * @see https://wiki.multitheftauto.com/wiki/DxGetTexturePixels
 * @noSelf
 */
export declare function dxGetTexturePixels(
    texture: Element,
    x?: number,
    y?: number,
    width?: number,
    height?: number,
): string;

/**
 * This function retrieves the theoretical width (in pixels) of a certain piece of text, if
 * it were to be drawn using dxDrawText.
 * NOTE: This function already takes the clients screen resolution into account.
 * @see https://wiki.multitheftauto.com/wiki/DxGetTextWidth
 * @param text A string representing the text for which you wish to retrieve with width for.
 * @param scale The size of the text.
 * @param font Either a custom DX font element or the name of a built-in dx font:
 * @param bColorCoded Should we exclude color codes from the width? (false will include the hex in the length)
 * Returns the float of the width of the text (in pixels).
 * @return returns the float of the width of the text (in pixels).
 * @noSelf
 */
export declare function dxGetTextWidth(
    text: string,
    scale?: number,
    font?: any,
    bColorCoded?: boolean,
): number;

/**
 * This function gets the current aspect ratio set by dxSetAspectRatioAdjustmentEnabled.
 * @see https://wiki.multitheftauto.com/wiki/DxIsAspectRatioAdjustmentEnabled
 * @return *boolean: returns true when enabled by dxsetaspectratioadjustmentenabled, false otherwise.
 * *float: aspect ratio set by dxsetaspectratioadjustmentenabled
 * @noSelf
 */
export declare function dxIsAspectRatioAdjustmentEnabled(): LuaMultiReturn<
    [boolean, number]
>;

/**
 * This function allows for the positioning of dxDraw calls to be automatically adjusted
 * according to the clients aspect ratio setting.  This lasts for a single execution of an
 * event handler for one of the following events: onClientRender, onClientPreRender and
 * onClientHUDRender. So the function has to be called every frame, just like dxDraws.
 * This is particularly useful for draws that must align with the GTA HUD, for which the
 * sizing and positioning can vary for different aspect ratios.
 * @see https://wiki.multitheftauto.com/wiki/DxSetAspectRatioAdjustmentEnabled
 * @param bEnabled : Should the adjustment be enabled or disabled.
 * @param sourceRatio This should be set to the aspect ratio the dxDraws were originally designed in.
 * @return returns true when it was changed successfully, or false otherwise.
 * @noSelf
 */
export declare function dxSetAspectRatioAdjustmentEnabled(
    bEnabled: boolean,
    sourceRatio?: number,
): boolean;

/**
 * This function sets the current blend mode for the dxDraw functions. Changing the blend
 * mode can increase the quality when drawing text or certain other images to a render
 * target. As a general guide use modulate_add when drawing text to a render target, and add
 * when drawing the render target to the screen. Dont forget to restore the default blend at
 * the end - See the example below.
 * @see https://wiki.multitheftauto.com/wiki/DxSetBlendMode
 * @param blendMode The blend mode to use which can be one of:
 * @param blend The source textures are alpha blended to the screen/render target. This is the default
 * mode for drawing and gives the results we all know and love.
 * @param add The source textures are added to the screen/render target.
 * @param modulate_add The source textures are multiplied by the alpha and then added to the screen/render
 * target.
 * @param overwrite The source textures are overwritten. This can be useful for clearing render targets.
 * @return returns true if successful, or false if invalid arguments were passed to the function.
 * @noSelf
 */
export declare function dxSetBlendMode(blendMode: string): boolean;

/**
 * This function sets the color of a single pixel for Texture_pixels|pixels contained in a
 * string. It only works with plain format pixels.
 * @see https://wiki.multitheftauto.com/wiki/DxSetPixelColor
 * @param pixels The pixels to use
 * @param x The X coordinate for the pixel
 * @param y The Y coordinate for the pixel
 * @param r The red channel for the color (0-255)
 * @param g The green channel for the color (0-255)
 * @param b The blue channel for the color (0-255)
 * @param a The alpha channel for the color (0-255)
 * @return returns true if successful, or false if invalid arguments were passed to the function.
 * @noSelf
 */
export declare function dxSetPixelColor(
    pixels: string,
    x: number,
    y: number,
    r: number,
    g: number,
    b: number,
    a?: number,
): boolean;

/**
 * @see https://wiki.multitheftauto.com/wiki/DxSetRenderTarget
 * @param renderTarget The render target element whose pixels we want to draw on.
 * @param clear If set to true, the render target will also be cleared.
 * @return returns true if the render target was successfully changed, false otherwise.
 * @noSelf
 */
export declare function dxSetRenderTarget(
    renderTarget?: Element,
    clear?: boolean,
): boolean;

/**
 * This function sets the amount of geometric sub-division to use when drawing a shader
 * element with dxDrawImage.
 * Using tessellation allows a shader to manipulate the shape of the rendered image at each
 * sub-division boundary.
 * @see https://wiki.multitheftauto.com/wiki/DxSetShaderTessellation
 * @param theShader The shader element whose tessellation is to be changed
 * @param tessellationX The number of sub-division points along the X axis. Range is 1 to 500.
 * @param tessellationY The number of sub-division points along the Y axis. Range is 1 to 500.
 * @return returns true if the shader elements tessellation was successfully changed, false
 * otherwise.
 * @noSelf
 */
export declare function dxSetShaderTessellation(
    theShader: Element,
    tessellationX: number,
    tessellationY: number,
): boolean;

/**
 * This function applies a 3D transformation to a shader element when it is drawn with
 * dxDrawImage.
 * @see https://wiki.multitheftauto.com/wiki/DxSetShaderTransform
 * @param theShader The shader element whose transformation is to be changed
 * @param rotationX Rotation angle in degrees around the X axis (Left,right). This will make the shader
 * rotate along its width.
 * @param rotationY Rotation angle in degrees around the Y axis (Up,down). This will make the shader rotate
 * along its height.
 * @param rotationZ Rotation angle in degrees around the Z axis (In,out). This will make the shader rotate in
 * a similar way to the rotation argument in dxDrawImage.
 * @param rotationCenterOffsetX The center of rotation offset X position in screen relative units.
 * @param rotationCenterOffsetY The center of rotation offset Y position in screen relative units.
 * @param rotationCenterOffsetZ The center of rotation offset Z position in screen relative units.
 * @param bRotationCenterOffsetOriginIsScreen Set to boolean|true if the center of rotation origin should be the center of the screen
 * rather than the center of the image.
 * @param perspectiveCenterOffsetX The center of perspective offset X position in screen relative units.
 * @param perspectiveCenterOffsetY The center of perspective offset Y position in screen relative units.
 * @param bPerspectiveCenterOffsetOriginIsScreen Set to boolean|true if the center of perspective origin should be the center of the
 * screen rather than the center of the image.
 * To convert screen relative units into screen pixel coordinates, ''multiply'' by the
 * screen size. Conversely, to convert screen pixel coordinates to screen relative units,
 * '''''divide''''' by the screen size.
 * @return returns true if the shader elements transform was successfully changed, false otherwise.
 * @noSelf
 */
export declare function dxSetShaderTransform(
    theShader: Element,
    rotationX: number,
    rotationY: number,
    rotationZ: number,
    rotationCenterOffsetX?: number,
    rotationCenterOffsetY?: number,
    rotationCenterOffsetZ?: number,
    bRotationCenterOffsetOriginIsScreen?: boolean,
    perspectiveCenterOffsetX?: number,
    perspectiveCenterOffsetY?: number,
    bPerspectiveCenterOffsetOriginIsScreen?: boolean,
): boolean;

/**
 * This sets a named parameter for a shader element
 * @see https://wiki.multitheftauto.com/wiki/DxSetShaderValue
 * @param theShader The shader element whose parameter is to be changed
 * @param parameterName The name of parameter
 * @param value The value to set, which can be a texture, a bool, a number or a list of numbers(max 16
 * floats(numbers))
 * @return returns true if the shader elements parameter was successfully changed, false otherwise.
 * @noSelf
 */
export declare function dxSetShaderValue(
    theShader: Element,
    parameterName: string,
    value: any,
): boolean;

/**
 * This function is used for testing scripts written using guiCreateFont, dxCreateFont,
 * dxCreateShader and dxCreateRenderTarget.
 * Each one of the 3 test modes should be used in turn to help highlight any potential
 * problems.
 * @see https://wiki.multitheftauto.com/wiki/DxSetTestMode
 * @param testMode The test mode to be set. It can be one of the following values:
 * @param none Test mode disabled
 * @param no_mem Simulate no free video memory available for MTA.
 * @param low_mem Simulate little free video memory available for MTA.
 * @param no_shader Simulate shaders failing validation.
 * @return returns true if the test mode was successfully set, false otherwise.
 * @noSelf
 */
export declare function dxSetTestMode(testMode: string): boolean;

/**
 * This functions allows you to change the edge handling after creating the texture.
 * @see https://wiki.multitheftauto.com/wiki/DxSetTextureEdge
 * @param theTexture The affected texture
 * @param textureEdge The texture edge mode. Available modes are wrap, mirror, clamp, border, mirror-once
 * @param border-color If textureEdge is set to border, you are able to define a border color here
 * @noSelf
 */
export declare function dxSetTextureEdge(
    theTexture: DxTexture,
    textureEdge: string,
    border_color?: number,
): boolean;

/**
 * This function sets the Texture_pixels|pixels of a texture element. It can be used with a
 * standard texture, render target or screen source. Only plain format pixels please.
 * * This function is slow and not something you want to be doing once a frame.
 * * It is very slow when setting pixels to a render target or screen source.
 * * And is very slow indeed if the texture format is not argb.
 * @see https://wiki.multitheftauto.com/wiki/DxSetTexturePixels
 * @param texture The texture element to set the pixels of
 * @param pixels The plain format pixels to use
 * @param surfaceIndex Desired slice to set if the texture is a volume texture, or desired face to set if the
 * texture is a cube map. <nowiki>(Cube map faces: 0=+X 1=-X 2=+Y 3=-Y 4=+Z 5=-Z)</nowiki>
 * By default the pixels are set starting at the top left corner of the texture. To set a
 * different region, define a rectangular area using all four of these optional arguments:
 * @param x Rectangle left position
 * @param y Rectangle top position
 * @param width Rectangle width
 * @param height Rectangle height
 * @return returns a string if successful, false if invalid arguments were passed to the function.
 * @noSelf
 */
export declare function dxSetTexturePixels(
    surfaceIndex: number,
    texture: Element,
    pixels: string,
    x?: number,
    y?: number,
    width?: number,
    height?: number,
): boolean;

/**
 * @see https://wiki.multitheftauto.com/wiki/DxSetTexturePixels
 * @noSelf
 */
export declare function dxSetTexturePixels(
    texture: Element,
    pixels: string,
    x?: number,
    y?: number,
    width?: number,
    height?: number,
): boolean;

/**
 * This function updates the contents of a screen source texture with the screen output from
 * GTA
 * @see https://wiki.multitheftauto.com/wiki/DxUpdateScreenSource
 * @param screenSource The screen source element whose pixels we want to fill with the screen capture
 * @param resampleNow A bool to indicate if the screen should be captured immediately. The default is false
 * which means the screen from the end of the previous frame is used (better for performance
 * and consistency). Use true for layering fullscreen effects.
 * @return returns true if the screen was successfully captured, false otherwise.
 * @noSelf
 */
export declare function dxUpdateScreenSource(
    screenSource: Element,
    resampleNow?: boolean,
): boolean;
